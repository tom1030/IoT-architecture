1. FreeRTOS
  1.1 Task
    a. States
      - Running
        A task is actually executing.
      - Ready
        A task is able to execute but are not currently executing.
      - Blocked
        A task is currently waiting for either a temporal or external event.
      - Suspended
        A task cannot be selected to enter the Running state and do not have a time out, only can be resumed.
    b. Priorities
    
  1.2 Inter-task Communication
    a. Direct to task notifications
      - Each RTOS task has a 32-bit notification value, can use as lightweight semaphore to unblock a task.
    b. Steam & Message buffers
      - Task to task or interrupt to task communication primitives, be optimised for single reader single writer scenarios.
      - Data is passed by copy - the data is copied into the buffer by the sender and out of the buffer by the read.
    c. Queues
      - Queues are primary form of intertask communications, used as FIFO buffers with new data being sent to the back of the queue, 
        although data can also be sent to the front.
    d. Binary semaphore
      - Binary semaphores are used for both mutual exclusion and synchronisation purposes.
      - Binary semaphores do not include a priority inheritance mechanism, better choice for implementing synchronisation.
    e. Counting semaphore
      - Counting semaphores can be thought of as queues that have a length of more than one. 
      - Tasks are not interested in the data that is stored in the queue—just the number of items in the queue.
      - Typically are used for Counting events and resource management.
  1.3 Resource Management
    a. Priority Inversion
      - A higher priority task being delayed by a lower priority task in this manner is called ‘priority inversion’.
    b. Priority Inheritance
      - Priority inheritance works by temporarily raising the priority of the mutex holder to the priority of 
        the highest priority task that is attempting to obtain the same mutex.The low priority task that holds 
        the mutex ‘inherits’ the priority of the task waiting for the mutex.
    c. Mutexes
      - Mutexes include a priority inheritance mechanism, the better choice for implementing simple mutual exclusion.
      - If two tasks of different priority use the same mutex, then the FreeRTOS scheduling policy makes the order 
        in which the tasks will execute clear; the highest priority task that is able to run will be selected as the task 
        that enters the Running state.
      - If two tasks of same priority use the same mutex, the task A waiting for a mutex that held by task B will not pre-empt 
        when task B 'gives' the mutex, instead, task B will remain in the Running state and task A will simply move from the 
        Blocked state to the Ready state.
    d. Recursive Mutexes
      - A recursive mutex can be ‘taken’ more than once by the same task, and will be returned only after one call to ‘give’ the 
        recursive mutex has been executed for every preceding call to ‘take’ the recursive mutex.
    e. Deadlock
      - Deadlock occurs when two tasks cannot proceed because they are both waiting for a resource that is held by the other.
      - Use a time out that is a little longer than the maximum time it is expected to have to wait for the mutex.
